[자바의 정석 3판 ch2~ch6까지의 내용을 정리]
----------------------------------------------------------------------------------------------

1. GIT fork = 내 계정 하위에 다른 사람 레포지토리 복제본을 갖고올수 있도록 하는 기능

2. version control system 코드 형상 관리 시스템 (intelliJ 메뉴에 존재, ex.GIT )

3. 기본형, 참조형 변수
기본형 : short, int, long, double, float, char, boolean
참조형 : 기본형 변수들 외 변수 (String, etc) / 실제 값이 아닌 주소 값(참조값)을 저장함

4. static 정적
static은 오브젝트(객체)가 아닌 '클래스'에 귀속되는 것들(변수/메서드/클래스)를 명시하기 위한 키워드이다.
static을 사용할 경우 메모리에서 static 부분에 고정된 공간이 할당되기 때문에 객체 선언을 할 필요 없이 모든 객체가 사용할 수 있으며,
해당 메소드/변수는 공유된다(변수는 값이 공유됨=객체 생성을 한다고 변수가 초기화되지 않음).
BUT static 메소드에서 접근하기 위한 변수는 반드시 static 변수로 선언되어야함.

5. 클래스, 객체 개념
클래스는 붕어빵 틀이라면, 객체는 실제 붕어빵(소스와 반죽은 객체를 만들때 선택 가능)

6. 오버로딩, 오버라이딩
오버로딩 = 생성자를 만들 때 주로 사용됨. 메소드에서 매개 변수를 달리하여 여러 개 선언할 수 있게함
오버라이딩 = 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하여 사용하는 것(완전 동일 메소드를 덮어씀)


7. openJDK, IDE, JRE, JVM
    7.1 JVM : .class 파일을 읽음, 검증, 실행 가능 && 필요한 클래스/변수/메서드들을 메모리에 생성

        [JVM에서 메모리 영역 구분] - static / stack / heap

        static  : static이 붙은 메소드, 변수들 올라감, JVM 종료 시점까지 사라지지 않고 유지, GC에 영향 받지 않음(static을 남발하지않도록 메모리 관리에 유의할 것)
        stack   : 메서드 호출시마다 각각 프레임{}이 생성, 호출된 메서드의 연산시 일어나는 값들을 임시로 저장 -> 메서드 수행 끝나면 프레임별로 삭제,
        스레드가 시작될 때 stack 영역에 생성됨 (1 스레드=static, stack, heap / static, heap 공유), 메소드를 호출할 때마다 push-pop 동작 수행 (FILO 구조)
        heap    : 인스턴스가 생성되는 공간, new로 생성된 객체, 배열들이 올라감, 힙 영역에서 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조, 참조하는 변수나 필드가 없다면 GC에 의해 제거됨

   7.2 JRE : JVM이 자바 프로그램 실행시킬 때 필요한 라이브러리 파일 및 기타 파일 가지고 있음
   7.3 JDK : JRE+개발을 위해 필요한 도구(javac, java) 포함


gradle -> build tool (java utility prog) -> cmd로 build할수 있도록, library 쉽게 가져오도록
Ant, maven, gradle
(하다 맘..기억 안남)

[코드 리펙토링]
1. 입력, 그리는 모듈을 나눈다
2. 예외 처리를 명시적으로 한다 (더 예외적인 상황을 고려하여 만든다)
3. 중복코드를 없앤다
4. 메시지용 상수 클래스도 따로 만들어주면 계속 메시지를 적을 필요 없어서 좋다 (static, public, final)